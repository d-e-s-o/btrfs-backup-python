# repository.py

#/***************************************************************************
# *   Copyright (C) 2015 Daniel Mueller (deso@posteo.net)                   *
# *                                                                         *
# *   This program is free software: you can redistribute it and/or modify  *
# *   it under the terms of the GNU General Public License as published by  *
# *   the Free Software Foundation, either version 3 of the License, or     *
# *   (at your option) any later version.                                   *
# *                                                                         *
# *   This program is distributed in the hope that it will be useful,       *
# *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
# *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
# *   GNU General Public License for more details.                          *
# *                                                                         *
# *   You should have received a copy of the GNU General Public License     *
# *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
# ***************************************************************************/

"""Repository related functionality.

  This program uses the abstraction of a repository to reason about
  which files to transfer in order to create a backup of a btrfs
  subvolume. A repository is a directory that contains or is supposed to
  contain snapshots.
"""

from datetime import (
  datetime,
)
from deso.btrfs.alias import (
  alias,
)
from deso.btrfs.command import (
  show,
  snapshots as listSnapshots,
)
from deso.execute import (
  executeAndRead,
)
from os.path import (
  dirname,
  join,
)
from re import (
  compile as regex,
)


_TIME_FORMAT = "%Y-%m-%d_%H:%M:%S"
_ANY_STRING = r"."
_NUM_STRING = r"[0-9]"
_NUMS_STRING = r"{nr}+".format(nr=_NUM_STRING)
_DATE_STRING = r"{nr}{{4}}-{nr}{{2}}-{nr}{{2}}".format(nr=_NUM_STRING)
_TIME_STRING = r"{nr}{{2}}:{nr}{{2}}:{nr}{{2}}".format(nr=_NUM_STRING)
_PATH_STRING = r"{any}+".format(any=_ANY_STRING)
# The format of a line as retrieved by executing the command returned by
# the snapshots() function. Each line is expected to be following the
# pattern:
# ID A gen B cgen C top level D otime 2015-01-01 18:40:49 path PATH
_LIST_STRING = (r"^ID {nums} gen {nums} cgen {nums} top level {nums}"
                r" otime ({date}) ({time}) path ({path})$")
_LIST_REGEX = regex(_LIST_STRING.format(nums=_NUMS_STRING, date=_DATE_STRING,
                                        time=_TIME_STRING, path=_PATH_STRING))
# The first line in the output generated by executing the command
# returned by the show() should contain the subvolume path if the
# given directory is a subvolume. However, if it is the root of the
# btrfs file system then it will end in 'is btrfs root'. We need to
# detect this case to determine the btrfs root.
_SHOW_IS_ROOT = "is btrfs root"


def _parseListLine(line):
  """Parse a line of output for the command as returned by snapshots()."""
  m = _LIST_REGEX.match(line)
  if not m:
    raise ValueError("Invalid snapshot list: unable to match line \"%s\"" % line)

  date, time, path = m.groups()

  result = {}
  result["time"] = datetime.strptime("%s_%s" % (date, time), _TIME_FORMAT)
  result["path"] = path
  return result


def _snapshots(directory):
  """Retrieve a list of snapshots in a directory.

    Note:
      Because of a supposed bug in btrfs' handling of passed in
      directories, the output of this function is *not* necessarily
      limited to subvolumes *below* the given directory. See test case
      testRepositoryListNoSnapshotPresentInSubdir. For that matter,
      usage of this function is discouraged. Use the Repository's
      snapshots() method instead.
  """
  output = executeAndRead(*listSnapshots(directory))
  # We might retrieve an empty output if no snapshots were present. In
  # this case, just return early here.
  if not output:
    return []

  # Convert from byte array and split to retrieve a list of lines.
  output = output.decode("utf-8").splitlines()
  return [_parseListLine(line) for line in output]


def _isRoot(directory):
  """Check if a given directory represents the root of a btrfs file system."""
  output = executeAndRead(*show(directory))
  output = output.decode("utf-8")[:-1].split("\n")

  # The output of show() contains multiple lines in case the given
  # directory is a subvolume. In case it is an ordinary directory the
  # output is a single line and begins with "ERROR:" (but the command
  # actually succeeds), and in case of the root directory it will be
  # matched here.
  return len(output) == 1 and output[0].endswith(_SHOW_IS_ROOT)


def _findRoot(directory):
  """Find the root of the btrfs file system containing the given directory."""
  assert directory

  # Note that we have no guard here against an empty directory as input
  # or later because of a dirname invocation. However, the show command
  # in _isRoot will fail for an empty directory (a case that will also
  # be hit if this function is run on a non-btrfs file system).
  while not _isRoot(directory):
    new_directory = dirname(directory)

    # Executing a dirname on the root directory ('/') just returns the
    # root directory. Guard against endless loops.
    if new_directory == directory:
      raise FileNotFoundError("Root of btrfs file system not found for "
                              "directory: \"%s\"" % directory)

    directory = new_directory

  return directory


def _trail(path):
  """Ensure the path has a trailing separator."""
  return join(path, "")


class Repository:
  """This class represents a repository for snapshots."""
  def __init__(self, directory):
    """Initialize the object and bind it to the given directory."""
    self._root = _findRoot(directory)
    self._directory = _trail(directory)


  def snapshots(self):
    """Retrieve a list of snapshots in this repository."""
    snapshots = _snapshots(self._directory)

    # We need to work around the btrfs problem that not necessarily all
    # snapshots listed are located in our repository's directory.
    with alias(self._directory) as prefix:
      # We only want to loop once but we need to remove items during
      # iteration. So we iterate over a *copy* while deleting from the
      # original. In order to ensure all indices are valid even in the
      # face of deletion, we need to iterate from back to front. The
      # enumerate function counts in ascending order so for the deletion
      # we need to subtract the index from the length of the original
      # array but because of reverse iteration we need to subtract one
      # more.
      rlen = len(snapshots) - 1
      copy = snapshots.copy()

      for i, snapshot in enumerate(reversed(copy)):
        # Make all paths absolute.
        path = join(self._root, snapshot["path"])
        # Check if the snapshot is not located in this repository's
        # directory.
        if path.startswith(prefix):
          # Valid snapshot. Remove the now common prefix.
          snapshot["path"] = path[len(prefix):]
        else:
          # Snapshot not in our directory. Remove it from the list.
          del snapshots[rlen - i]

      # TODO: We currently return a list of snapshots in the internally
      #       used format, i.e., a dict that contains a 'path' and a
      #       'gen' key. Clients should not require the latter
      #       information and, thus, only the paths should be exposed to
      #       the outside. Such a change might require some adjustments,
      #       however, and it is unclear whether it is worth the effort.
      return snapshots


  def path(self, *components):
    """Form an absolute path by combining the given path components."""
    return join(self._directory, *components)
